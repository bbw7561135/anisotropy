#!/usr/bin/env python

import numpy as np
from scipy.interpolate import interp1d
from scipy.integrate import quad
import matplotlib.pyplot as plt
import argparse
import os, re, sys
import colormaps as cmaps
#from plots import eres2
from useful import getMids

if __name__ == "__main__":

	parser = argparse.ArgumentParser(description='Calculate anisotropy')
	parser.add_argument('--nbins', dest='num_bins', type=int, default=6, help='Number of points to be used')
	parser.add_argument('--lowerb', dest='lower_bound', default=False, action='store_true', help='Use extended lower bound')
	parser.add_argument('--out', dest='out', default=False, action='store_true', help='Save plots')

	args = parser.parse_args()
	
	
	# Basic setup
	xmin = 2.75
	xmax = 9.01
	step_size = 0.05
	number_steps = (xmax-xmin)/step_size
	energy_axis = np.linspace(xmin,xmax,num=number_steps, endpoint=True)
	
	fig, ax = plt.subplots()
	f = np.load('/home/fmcnally/anisotropy/icesim/IC59_hists.npy')
	
	# Energy binning information
	ebins = np.arange(xmin, xmax, step_size)
	x = getMids(ebins)
	#print('mid = {}'.format(x))
	rel_freq = []
	for i, y in enumerate(f):
		#print('enumerate(f) = {}'.format(enumerate(f)))
		#print('ntot = {}'.format(y.sum()))
		#print ('i,y = {},{}'.format(i,y))
		ntot = float(y.sum())
		ax.step(x, y/ntot, label=i+1)
		rel_freq.append(y/ntot)
	print('rel_freq[3] = {}'.format(rel_freq[3]))

	ax.set_xlim(2.75, 8.5)
	tPars = {'fontsize':16}
	ax.set_xlabel(r'True Energy ($\log_{10}(E/\mathrm{GeV})$)', **tPars)
	ax.set_ylabel('Fraction of Events', **tPars)
	plt.legend(loc='upper right')

	if args.out != False:
		plt.savefig(out, dpi=300, bbox_inches='tight')
	
	# Read in unnormalized fraction of events data (unnormalized y-axis in Figure 2)
	events = []
	with open('spencerTable.txt') as inputfile:
		for line in inputfile:
			events_str = line.strip().split(',')
			events.append([float(x) for x in events_str])

	# Create corresponding energy axis points (x-axis in Figure 2)
	xmin = 2.75
	xmax = 9.0
	number_steps = (xmax-xmin)/0.05
	energy_axis = np.linspace(xmin,xmax,num=number_steps, endpoint=True)
	
	# Find relative frequency histogram for the number of events data
	# Plot my version of Figure 2 as a check
	plt.figure(7)
	for i in range(len(events)):
		plt.plot(energy_axis,[x/sum(events[i]) for x in events[i]],marker='None', linestyle='-',label='{}'.format(i+1))
	plt.axis((2.75,8.5,0.0,0.06))
	tPars = {'fontsize':14}
	plt.xlabel(r'True Energy ($\log_{10}(E/\mathrm{GeV})$)', **tPars)
	plt.ylabel('Fraction of Events', **tPars)
	plt.legend()
	plt.savefig('figure2',dpi=300, bbox_inches='tight')
	
	# Calculate desired energy bin widths (derived from Figure 8)		
	energy_centers = [4.12, 4.38, 4.58, 4.85, 5.12, 5.38, 5.77, 6.13, 6.73]
	bins = [0.0]*len(energy_centers)
	for i in range(len(energy_centers)):
		if i == 0:
			bin_right = (energy_centers[i+1]-energy_centers[i])/2.0
			bin_left = bin_right
			if not args.lower_bound:
			    bins[i] = ([energy_centers[i]-bin_left,energy_centers[i]+bin_right])
			else:
			    bins[i] = ([3.0,energy_centers[i]+bin_right])
		if i == len(energy_centers)-1:
			bin_left = (energy_centers[i]-energy_centers[i-1])/2.0
			bin_right = bin_left
			bins[i] = ([energy_centers[i]-bin_left,energy_centers[i]+bin_right])
		if i != 0 and i != len(energy_centers)-1:
			bin_left = (energy_centers[i]-energy_centers[i-1])/2.0
			bin_right = (energy_centers[i+1]-energy_centers[i])/2.0
			bins[i] = ([energy_centers[i]-bin_left,energy_centers[i]+bin_right])
	
	# Calculate the N matrix elements
	def get_matrix_element(i,j):
		bin_min = bins[j][0]
		bin_max = bins[j][1]
		n_ij = 0.0
		for x in range(len(energy_axis)):
			if energy_axis[x] >= bin_min and energy_axis[x] < bin_max:
				n_ij += events[i][x]/sum(events[i])
		return n_ij
	
	N = []
	for i in range(args.num_bins):
		row = []
		for j in range(args.num_bins):
			row.append(get_matrix_element(i,j))
		N.append(row)
	#print(np.matrix(N))
	#print(np.matrix(N).getA())
	#print(np.matrix(N).getI())
	#print(np.matrix(N).getI()*np.matrix(N))
	
	plt.figure(2)
	mat = plt.matshow(np.matrix(N).getI(),fignum=2, cmap=cmaps.viridis)
	#mat = plt.matshow(np.matrix(N).getI(),fignum=2, cmap=plt.get_cmap('coolwarm'))
	plt.colorbar(mat, orientation='vertical')
	plt.figure(4)
	im = plt.matshow(np.matrix(N), fignum=4, cmap=cmaps.viridis)
	#im = plt.matshow(np.matrix(N), fignum=4, cmap=plt.get_cmap('coolwarm'))
	plt.colorbar(im, orientation='vertical')

	anisotropy_data = [7.32170723e-04, 6.96619874e-04, 4.82783053e-04, 2.85341450e-04, 1.60042336e-04, 7.31462195e-05, 2.00920356e-04, 5.00927901e-04, 6.52328253e-04]
	data_used = []
	for i in range(args.num_bins): 
		data_used.append(anisotropy_data[i])
	#print(np.matrix(A))
	#print(np.matmul(np.matrix(N).getI().getA(),np.matrix(A).getA()))
	sol = np.linalg.solve(np.array(N),np.array(data_used))
	print(sol)

	def d_I(E):
		for i in range(args.num_bins):
			lower = bins[i][0]
			upper = bins[i][1]
			#if E < bins[0][0] or E > bins[len(bins)-1][1]:
			#	return 'Not in range.'
			if E >= lower and E < upper:
				return sol[i]
	
	plt.figure(3)
	for i in range(args.num_bins):
	    lower = bins[i][0]
	    upper = bins[i][1]
	    xnew = np.arange(lower, upper, 0.01);
	    plt.plot(xnew, [d_I(x) for x in xnew], marker='None', linestyle='-', linewidth=2.0, color='g') 
#	plt.axis((3.0,6.0,-1.5,2.0))
	plt.xlabel(r'True Energy [$\log_{10}$(E/GeV)]')
	plt.ylabel(r'$\delta I(E)$')
	plt.show()

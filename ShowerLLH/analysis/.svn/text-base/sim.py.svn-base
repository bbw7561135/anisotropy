#!/usr/bin/env python

################################################################################
## Look at the cut efficiency (requires load_sim.py)                          ##
################################################################################

from numpy import *
from scipy import optimize
from useful import *
import matplotlib.pyplot as plt
import time


##===========================================================================##
## Plotting functions

""" Return the median, upper, and lower 34% containment for an array """
def getMed(x):
    if len(x)==0:
        return 0, 0, 0
    x.sort()
    med_index  = len(x)/2
    sigma_step = len(x)*34/100
    med = x[med_index]
    sigma_min = med - x[med_index - sigma_step]
    sigma_max = x[med_index + sigma_step] - med
    return med, sigma_min, sigma_max


""" Get the energy resolution """
def eres(s, cut, st=45, ndiv=5, ideal=False):

    # Setup plot
    plt.title('Energy Resolution vs True Energy')
    plt.xlabel('Log10(Energy/GeV)')
    plt.ylabel('Ereco - Etrue (median)')

    # Plot Ereco histograms for each energy bin in Etrue
    t = log10(s['MC_energy'][cut])
    r = log10(s['ML_energy'][cut])
    Ebins, Emids = getEbins(), getEmids()
    if ideal:
        r = (log10(s['pML_energy']*s['P'] + s['hML_energy']*s['He'] + 
                s['oML_energy']*s['O'] + s['fML_energy']*s['Fe']))[cut]

    # Group into larger bins in energy
    nplt = len(Emids[st:])/ndiv
    x, med, min, max = zeros((4,nplt))

    for j in range(nplt):
        start = j*ndiv + st
        end = (j+1)*ndiv + st
        e_cut = (t >= Ebins[start]) * (t < Ebins[end])
        y = (r - t)[e_cut]

        # Store median and standard deviation info
        x[j] = (Ebins[end] + Ebins[start]) / 2.
        med[j], min[j], max[j] = getMed(y)

    # Plot energy resolution
    plt.errorbar(x, med, yerr=(min,max), fmt='.')
    plt.show()    


""" Get the core resolution """
def core_res(s, cut, st=45, ndiv=5):

    # Setup plot
    plt.title('Core Resolution vs True Energy')
    plt.xlabel('Log10(Energy/GeV)')
    plt.ylabel('Reco_core - True_core (median)')

    # Plot Ereco histograms for each energy bin in Etrue
    t = log10(s['MC_energy'][cut])
    tx, ty = s['MC_x'][cut], s['MC_y'][cut]
    rx, ry = s['ML_x'][cut], s['ML_y'][cut]
    Ebins, Emids = getEbins(), getEmids()

    # Group into larger bins in energy
    nplt = len(Emids[st:])/ndiv
    x, med, min, max = zeros((4,nplt))

    for j in range(nplt):
        start = j*ndiv + st
        end = (j+1)*ndiv + st
        e_cut = (t >= Ebins[start]) * (t < Ebins[end])
        y = sqrt((rx-tx)**2 + (ry-ty)**2)[e_cut]

        # Store median and standard deviation info
        x[j] = (Ebins[end] + Ebins[start]) / 2.
        med[j], min[j], max[j] = getMed(y)

    # Plot energy resolution
    plt.errorbar(x, med, yerr=(min,max), fmt='.')
    plt.show()


""" Plot the counts """
def counts(s, cut, name=""):

    # Plot the pure number of counts before unfolding
    r = log10(s['ML_energy'])
    t = log10(s['MC_energy'])
    Emids = getEmids()
    #compDict = {'p':'P','h':'He','o':'O','f':'Fe'}
    compDict = {'p':'P', 'f':'Fe'}
    colorDict = {'p':'b', 'h':'y', 'o':'c', 'f':'r', 'All':'k'}

    plt.title('Counts using '+name+' cut')
    plt.xlabel('Log10(Energy/GeV)')
    plt.ylabel('Counts')

    # Get the counts
    N = {}
    N['All'] = Nfinder(r, cut)
    for e in compDict.keys():
        N[e] = Nfinder(r, cut*s[e])

    # Plot reconstructions
    for e in compDict.keys() + ['All']:
        pnt = colorDict[e] + '.'
        plt.errorbar(Emids, N[e], yerr=sqrt(N[e]), fmt=pnt, label=e)

    # MC True values
    for e in compDict.keys():
        true = compDict[e]
        pnt = colorDict[e] + 'x'
        plt.plot(Emids, Nfinder(t, cut*s[true]), pnt)
    plt.plot(Emids, Nfinder(t, cut), 'kx')

    plt.yscale('log')
    plt.legend(loc='upper right')
    plt.ylim([10**(0),10**(6)])

    plt.show()


""" 2-D histogram of ML energy vs MC energy """
def hist2d(s, cut, log=True):

    # Setup 2D histogram of Ereco (y) vs Etrue (x) for ML reconstruction
    f = plt.figure()
    ax1 = f.add_subplot(1,1,1)
    ax1.set_title('Etrue vs Ereco (actual composition)')
    ax1.set_xlabel('log10(MC/GeV)')
    ax1.set_ylabel('log10(LLH/GeV)')

    ## x translates to the y-axis and vice versa ##
    x = log10(s['ML_energy'][cut])
    y = log10(s['MC_energy'][cut])
    Ebins   = getEbins()
    myBins  = len(Ebins)-1
    myRange = (4, 9.5)

    h, xedges, yedges = histogram2d(x, y, bins=myBins, range=(myRange,myRange), normed=False, weights=None)
    extent = [yedges[0], yedges[-1], xedges[0], xedges[-1]]
    if log:
        h = log10(h)

    im = ax1.imshow(h, extent=extent, origin='lower')
    f.colorbar(im)
    plt.show()


""" Look at a given parameter split for both iron and proton """
def pfplot(s, varName, bins=10, xlog=False, ylog=False):

    f = plt.figure()
    ax1 = f.add_subplot(1,1,1)
    ax1.set_title(varName)
    ax1.set_xlabel(varName)
    ax1.set_ylabel('counts')

    cut = s['cuts']['llh']
    nancut = (s[varName]==s[varName])
    cut *= nancut

    for e in ['P', 'H', 'O', 'F']:
        c0 = cut * s[e]
        x = s[varName][c0]
        h, myBins, temp = ax1.hist(x, bins=bins, histtype='step', label=e)

    ax1.legend(loc='lower left')
    if xlog:
        ax1.set_xscale('log')
    if ylog:
        ax1.set_yscale('log')

    plt.show()






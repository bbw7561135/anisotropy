#!/usr/bin/env python

###############################################################################
## An attempt to update the TimeScramble.cc code to run with ShowerLLH       ##
###############################################################################

from icecube import astro
from numpy import *
import healpy, sys


# Takes data - dictionary of events
def timeScramble(d, yyyymmdd, nInt, method='equatorial'):

    # Constants
    data = {}
    nSide = 64
    nBGResample = 20            # Number of times to resample events for bg
    alpha = 1./nBGResample
    if 24%nInt != 0:
        print 'Integration time does not work cleanly into 24 hours!'
        sys.exit(1)
    dt = nInt / 24.             # Integration time (days)

    # Setup maps
    nPixels = hp.nside2npix(nSide)
    maps = {}
    for key in ['Local', 'Data', 'BG', 'Signal']:
        maps[key] = zeros(nPixels)

    # Astro parameters
    ice = astro.IceCubeDetector()
    local = astro.LocalCoord()
    t = astro.Time()

    # Extract date information
    yy = int(yyyymmdd[:4])
    mm = int(yyyymmdd[4:6])
    dd = int(yyyymmdd[6:])

    # Just look at events in a 1 day period
    t = astro.Time()
    t.SetTime(yy, mm, dd, 0, 0, 0)
    mjd0 = t.GetMJD()
    mjd1 = mjd0 + 1

    # Apply cuts to restrict range to a day
    time_cut = (d['mjd'] > mjd0) * (d['mjd'] < mjd1)
    for key in d.keys():
        data[key] = d[key][time_cut] 

    mjd_start = mjd0
    for t_segment in range(24/nInt):
        temp_cut = (data['mjd'] > mjd_start) * (data['mjd'] < mjd_start+dt)
        for key in data.keys():
            temp = data[key][temp_cut]
        temp_maps = scrambler(temp, nSide, method)
        mjd_start = mjd_start + dt

        # Update maps for this time interval
        for key in temp_maps.keys():
            maps[key] += temp_maps[key]

    maps['BG'] *= alpha
    maps['Signal'] = LMSignificance(maps['Data'], maps['BG'], alpha)

    # Save to file
    outPrefix = outDir + fileBase+'_'+nInt+'H'
    for key in maps.keys():
        hp.write_map(outPrefix+'_'+key.lower()+'.fits', maps[key])


def scrambler(data, nSide, method):

    # Astro parameters
    ice = astro.IceCubeDetector()
    local = astro.LocalCoord()
    t = astro.Time()

    # Setup maps
    temp_maps = {}
    nPixels = hp.nside2npix(nSide)
    for key in ['Local', 'Data', 'BG']:
        temp_maps[key] = zeros(nPixels)    

    # Begin looping through data

    for i in range(len(data['mjd'])):

        theta = data['zenith'][i]
        phi = data['azimuth'][i]
        if theta > pi/2:
            continue

        # Fill local map
        pixelID = hp.ang2pix(nSide, theta, phi)
        temp_maps['Local'][pixelID] += 1.0

        # Fill equatorial map
        t.SetTime(data['mjd'][i])
        local.SetLocalRad(theta, phi)
        dec, ra = l2e(ice, local, t, method=method)
        pixelID = hp.ang2pix(nSide, dec, ra)
        temp_maps['Data'][pixelID] += 1.0

    # Once local and equatorial maps are filled, scramble times
    for i in range(len(data['mjd'])):
        theta = data['zenith'][i]
        phi = data['azimuth'][i]

        for j in range(nBGResample):
            rndMJD = random.choice(data['mjd'])
            t.SetTime(rndMJD)
            local.SetLocalRad(theta, phi)
            dec, ra = l2e(local, t, method=method)
            pixelID = hp.ang2pix(nSide, dec, ra)
            temp_maps['BG'][pixelID] += 1.0

    return temp_maps


# Li Ma Significance
def LMSignificance(nData, nBG, alpha):

    Non  = nData
    Noff = nBG / alpha
    sn = sign(Non - nBG)
    sigma = sn * sqrt(2 * (Non * log(((1+alpha)*Non) / (alpha*(Non+Noff))) + 
            Noff * log(((1+alpha)*Noff) / (Non+Noff))))

    # Check for nan's
    nanCatch = (sigma!=sigma)
    sigma[nanCatch] = 0

    return sigma


# General local to equatorial conversion
def l2e(local, t, method='equatorial'):

    ice = astro.IceCubeDetector()

    if (method == 'equatorial'):
        eqApparent = ice.LocalToEquatorial(local, t)
        phi = eqApparent.GetRaRad()
    if (method == 'anti_sid'):
        eqApparent = ice.LocalToEquatorial_FromAntiSid(local, t)
        phi = eqApparent.GetRaRad()
    if (method == 'ext_sid'):
        eqApparent = ice.LocalToEquatorial_FromExtSid(local, t)
        phi = eqApparent.GetRaRad()
    if (method == 'solar'):
        eqApparent = ice.LocalToEquatorial(local, t)
        eqSolar = ice.PlanetToEquatorial(0, t)
        phi = eqApparent.GetRaRad() - eqSolar.GetRaRad()

    theta = pi/2 - eqApparent.GetDecRad()
    if phi < 0:
        phi += 2*pi

    return theta, phi













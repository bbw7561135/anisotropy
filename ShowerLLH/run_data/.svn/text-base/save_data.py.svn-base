#!/usr/bin/env python

###########################################################################
# Takes a list of processed hdf5 files and returns desired information    #
# as a binary dictionary for rapid reading for use with plotting          #
# Usage: save_data.py [config]                                            #
###########################################################################

import sys, time, tables, glob
from numpy import *

if __name__ == "__main__":

    d = {}
    config = 'IT73'
    prefix = '/net/user/fmcnally/ShowerLLH/%s_data/' % config
    fileList = glob.glob(prefix + 'DataLLH_*.hdf5')
    fileList.sort()

    # Basic composition information
    comp = {'p':'proton', 'h':'helium', 'n':'nitrogen', 'o':'oxygen'}
    comp.update({'a':'aluminum','f':'iron'})
    #rList = ['p','h','o','f']
    rList = ['p','f']

    ##=======================================================================
    ## Keys to import

    arrays = []
    dicts  = {}

    # General event information
    arrays += ['SubEventStream', 'mjd_day', 'mjd_sec', 'mjd_ns']
    dicts['weights'] = ['w1','w1.5','w3']

    # ShowerLLH values
    arrays += ['rrc']
    for r in rList:
        arrays += [r+'LLH', r+'ML_energy', r+'ML_x', r+'ML_y']

    # Laputop values
    for key in ['x','y','zenith','azimuth','s125','e_proton','e_iron','beta']:
        arrays += ['lap_'+key]

    # Other reconstructions and cuts
    for key in ['zenith', 'azimuth']:
        arrays += ['ShowerPlane_'+key]

    # Initialize arrays
    for value in arrays:
        d[value] = array([])
    for key in dicts.keys():
        d[key] = {}
        for value in dicts[key]:
            d[key][value] = array([])

    t0 = time.time()
    for file in fileList:

        print "Working on", file
        t = tables.openFile(file)
        q = {}

        # General event information
        q['SubEventStream'] = t.root.I3EventHeader.col('SubEventStream')
        q['mjd_day'] = t.root.I3EventHeader.col('time_start_mjd_day')
        q['mjd_sec'] = t.root.I3EventHeader.col('time_start_mjd_sec')
        q['mjd_ns']  = t.root.I3EventHeader.col('time_start_mjd_ns')

        # Condition and prescale passed (filter[condition, prescale])
        # For notes on weights see bottom of file
        STA3   = t.root.FilterMask.col('IceTopSTA3_10')
        STA3ii = t.root.FilterMask.col('IceTopSTA3_InIceSMT_10')
        STA8   = t.root.FilterMask.col('IceTopSTA8_10')
        q['w1']   = STA8[:,0]
        q['w1.5'] = STA3ii[:,0] * logical_not(q['w1'])
        q['w3']   = STA3[:,0] * logical_not(q['w1']) * logical_not(q['w1.5'])

        # Get ShowerLLH cuts and info
        q['rrc'] = t.root.ShowerLLHParams.col('RecoRanCut')
        for value in ['x', 'y', 'energy']:
            q['pML_'+value] = t.root.ShowerLLH_proton.col(value)
            #q['hML_'+value] = t.root.ShowerLLH_helium.col(value)
            #q['oML_'+value] = t.root.ShowerLLH_oxygen.col(value)
            q['fML_'+value] = t.root.ShowerLLH_iron.col(value)
        for r in rList:
            q[r+'LLH'] = t.root.ShowerLLHParams.col('maxLLH_'+comp[r])

        # Get Laputop info
        for value in ['x', 'y', 'zenith', 'azimuth']:
            q['lap_'+value] = t.root.Laputop.col(value)
        for value in ['s125', 'e_proton', 'e_iron', 'beta']:
            q['lap_'+value] = t.root.LaputopParams.col(value)

        # Get other reconstruction info
        for value in ['zenith', 'azimuth']:
            q['ShowerPlane_'+value] = t.root.ShowerPlane.col(value)

        # append to existing arrays
        new = len(q['rrc'])
        old = len(d['rrc'])
        for value in arrays:
            d[value].resize(old+new)
            d[value][old:] = q[value]
        for key in dicts.keys():
            for value in dicts[key]:
                d[key][value].resize(old+new)
                d[key][value][old:] = q[value]

        t.close()

    # Create final elements
    full_llhs = array([d[r+'LLH'] for r in rList])
    max_llh = amax(full_llhs, axis=0)
    for r in rList:
        d[r] = (d[r+'LLH'] == max_llh)
    for value in ['x', 'y', 'energy']:
        d['ML_'+value] = sum([d[r+'ML_'+value]*d[r] for r in rList], axis=0)

    print "Time taken:", time.time()-t0
    print "Average time per run:", (time.time()-t0)/len(fileList)

    save(prefix + 'DataPlot.npy', d)



###############################################################################
## Notes on weights

"""
 - Events that pass STA8 condition have a prescale and weight of 1.
 - Events that pass STA3ii condition have a 1/2 chance to pass the STA3ii
prescale. Those that fail have a 1/3 chance to pass the STA3 prescale. So, the 
total chance of an event passing is 1/2+(1/3*1/2) = 2/3. Weight = 1.5
 - Events that pass STA3 condition but not STA3ii condition have a prescale and
weight of 3
"""
